<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='52'%3E%E2%9C%85%3C/text%3E%3C/svg%3E">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#349a79">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="assets/icons/icon-192.png">
    <title>Tasks</title>
</head>
<body>
    <div class="page-header">
        <h2>Tasks</h2>
        <div class="header-actions">
            <button id="import-tasks" aria-label="Import tasks" title="Import tasks">â†“</button>
            <button id="export-tasks" aria-label="Export tasks" title="Export tasks">â†‘</button>
            <button id="theme-toggle" aria-label="Toggle theme" title="Toggle theme">â˜½</button>
        </div>
    </div>
    <div class="categories-bar">
        <div id="category-tabs"></div>
        <button id="add-category" aria-label="Add category" title="Add category">+</button>
    </div>
    <section id="todo-section">
        <h3>To do</h3>
        <hr />
        <div id="todo-list"></div>
        <input id="new-task" type="text" placeholder="New task" />
    </section>

    <section id="done-section">
        <h3>Done</h3>
        <hr />
        <div id="done-list"></div>
    </section>
    <!-- Import Modal -->
    <div id="import-modal" class="modal" aria-hidden="true" role="dialog">
        <div class="modal-card" role="document">
            <div class="modal-title">Import Tasks</div>
            <div class="modal-body">
                <p class="modal-description">Select a JSON file to import tasks. This will replace your current tasks.</p>
                <input type="file" id="import-file" accept=".json,application/json" aria-label="Select JSON file" />
            </div>
            <div class="modal-actions-row">
                <button id="cancel-import" aria-label="Cancel" title="Cancel">Cancel</button>
                <button id="confirm-import" aria-label="Import" title="Import" disabled>Import</button>
            </div>
        </div>
    </div>
    <!-- Delete Category Confirmation Modal -->
    <div id="delete-category-modal" class="modal" aria-hidden="true" role="dialog">
        <div class="modal-card" role="document">
            <div class="modal-title">Delete Category</div>
            <div class="modal-body">
                <p class="modal-description">Are you sure you want to delete "<span id="delete-category-name"></span>"? This will permanently delete all tasks in this category.</p>
            </div>
            <div class="modal-actions-row">
                <button id="cancel-delete-category" aria-label="Cancel" title="Cancel">Cancel</button>
                <button id="confirm-delete-category" aria-label="Delete" title="Delete" class="danger-btn">Delete</button>
            </div>
        </div>
    </div>
    <!-- Minimal Install Banner (mobile only) -->
    <div id="install-banner" class="install-banner" aria-hidden="true">
        <span>Install app?</span>
        <button id="install-cta" aria-label="Install app" title="Install">Install</button>
        <button id="install-close" aria-label="Dismiss" title="Dismiss">âœ•</button>
    </div>
    <script>
        class JsonStorage {
            constructor(storageKey){
                this.storageKey = storageKey;
            }

            save(dataObject){
                localStorage.setItem(this.storageKey, JSON.stringify(dataObject));
            }

            load(){
                const json = localStorage.getItem(this.storageKey);
                if (!json) return null;
                try {
                    return JSON.parse(json);
                } catch (e) {
                    try { localStorage.removeItem(this.storageKey); } catch (_) {}
                    console.warn(`Invalid JSON in localStorage for key '${this.storageKey}'. Clearing it.`, e);
                    return null;
                }
            }

            remove(){
                localStorage.removeItem(this.storageKey);
            }
        }

        class Categories {
            constructor(onChangeCallback) {
                this.storage = new JsonStorage('categories');
                this.selectedStorage = new JsonStorage('selectedCategory');
                this.categories = this.storage.load() || {};
                this.selectedId = this.selectedStorage.load() || null;
                this.onChangeCallback = onChangeCallback;
                this.pendingDeleteId = null;
            }

            add(name) {
                const trimmedName = (name || '').trim();
                if (!trimmedName) return false;

                // Check for unique name
                if (this.nameExists(trimmedName)) {
                    alert('A category with this name already exists.');
                    return false;
                }

                const categoryId = crypto.randomUUID();
                const maxOrder = Math.max(-1, ...Object.values(this.categories).map(c => (c && typeof c.order === 'number') ? c.order : -1));
                this.categories[categoryId] = { name: trimmedName, order: maxOrder + 1 };
                this.storage.save(this.categories);

                // Auto-select the new category
                this.select(categoryId);
                console.log(`Category '${trimmedName}' created.`);
                return true;
            }

            remove(categoryId) {
                if (!this.categories[categoryId]) return false;
                delete this.categories[categoryId];
                this.storage.save(this.categories);

                // If deleted category was selected, select first available or null
                if (this.selectedId === categoryId) {
                    const remaining = Object.keys(this.categories);
                    this.select(remaining.length > 0 ? remaining[0] : null);
                }
                console.log(`Category '${categoryId}' removed.`);
                return true;
            }

            edit(categoryId, newName) {
                const trimmedName = (newName || '').trim();
                if (!trimmedName || !this.categories[categoryId]) return false;

                // Check for unique name (excluding current category)
                if (this.nameExists(trimmedName, categoryId)) {
                    alert('A category with this name already exists.');
                    return false;
                }

                this.categories[categoryId].name = trimmedName;
                this.storage.save(this.categories);
                console.log(`Category '${categoryId}' renamed to '${trimmedName}'.`);
                return true;
            }

            select(categoryId) {
                this.selectedId = categoryId;
                this.selectedStorage.save(categoryId);
                if (this.onChangeCallback) this.onChangeCallback();
            }

            nameExists(name, excludeId = null) {
                const lowerName = name.toLowerCase();
                return Object.entries(this.categories).some(([id, cat]) =>
                    id !== excludeId && cat.name.toLowerCase() === lowerName
                );
            }

            getSelected() {
                return this.selectedId;
            }

            getSorted() {
                return Object.entries(this.categories)
                    .sort((a, b) => (a[1].order || 0) - (b[1].order || 0));
            }

            getNameById(categoryId) {
                if (!categoryId || !this.categories[categoryId]) return null;
                return this.categories[categoryId].name;
            }

            render(container, deleteModal, deleteNameSpan) {
                if (!container) return;
                container.innerHTML = '';

                // Add "All" tab first
                const allTab = document.createElement('div');
                allTab.className = 'category-tab';
                if (this.selectedId === null) {
                    allTab.classList.add('active');
                }
                const allNameSpan = document.createElement('span');
                allNameSpan.className = 'category-name';
                allNameSpan.textContent = 'All';
                allNameSpan.addEventListener('click', () => {
                    this.select(null);
                    this.render(container, deleteModal, deleteNameSpan);
                });
                allTab.appendChild(allNameSpan);
                container.appendChild(allTab);

                const sorted = this.getSorted();

                for (const [categoryId, category] of sorted) {
                    const tab = document.createElement('div');
                    tab.className = 'category-tab';
                    tab.dataset.id = categoryId;
                    if (categoryId === this.selectedId) {
                        tab.classList.add('active');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'category-name';
                    nameSpan.textContent = category.name;
                    nameSpan.addEventListener('click', () => {
                        this.select(categoryId);
                        this.render(container, deleteModal, deleteNameSpan);
                    });

                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'ðŸ–‹';
                    editBtn.className = 'category-action';
                    editBtn.setAttribute('aria-label', 'Edit category');
                    editBtn.setAttribute('title', 'Edit category');
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const editInput = document.createElement('input');
                        editInput.type = 'text';
                        editInput.value = category.name;
                        editInput.className = 'category-edit-input';

                        editInput.addEventListener('keydown', (ev) => {
                            if (ev.key === 'Enter') {
                                const newName = editInput.value.trim();
                                if (newName && this.edit(categoryId, newName)) {
                                    this.render(container, deleteModal, deleteNameSpan);
                                }
                            } else if (ev.key === 'Escape') {
                                this.render(container, deleteModal, deleteNameSpan);
                            }
                        });

                        editInput.addEventListener('blur', () => {
                            this.render(container, deleteModal, deleteNameSpan);
                        });

                        tab.replaceChild(editInput, nameSpan);
                        editInput.focus();
                        editInput.select();
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'ðŸ—‘';
                    deleteBtn.className = 'category-action category-delete';
                    deleteBtn.setAttribute('aria-label', 'Delete category');
                    deleteBtn.setAttribute('title', 'Delete category');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.pendingDeleteId = categoryId;
                        if (deleteNameSpan) deleteNameSpan.textContent = category.name;
                        if (deleteModal) {
                            deleteModal.classList.add('open');
                            deleteModal.setAttribute('aria-hidden', 'false');
                        }
                    });

                    tab.appendChild(nameSpan);
                    // Only show edit/delete buttons for the active category
                    if (categoryId === this.selectedId) {
                        tab.appendChild(editBtn);
                        tab.appendChild(deleteBtn);
                    }
                    container.appendChild(tab);
                }
            }
        }

        class Tasks{
            constructor(categoriesInstance){
                this.storage = new JsonStorage('tasks');
                this.tasks = this.storage.load();
                this.draggingId = null;
                this.categories = categoriesInstance;
            }

            add(text){
                try{
                    const taskId = crypto.randomUUID();
                    const existing = this.tasks || {};
                    const categoryId = this.categories ? this.categories.getSelected() : null;
                    const maxOrder = Math.max(-1, ...Object.values(existing).map(t => (t && typeof t.order === 'number') ? t.order : -1));
                    const newTask = {"task": text, "done": false, "order": maxOrder + 1, "subtasks": [], "collapsed": false, "categoryId": categoryId};
                    this.tasks[taskId] = newTask;
                    this.storage.save(this.tasks);
                    console.log(`Task '${text}' created in category '${categoryId}'.`);

                    return true;

                } catch(err){
                    console.error(`An error ocurred on creating task '${text}':`, err.message);

                    return false;
                }
            }

            removeByCategory(categoryId) {
                if (!categoryId) return;
                const toRemove = Object.entries(this.tasks || {})
                    .filter(([_, task]) => task.categoryId === categoryId)
                    .map(([id]) => id);
                toRemove.forEach(id => delete this.tasks[id]);
                this.storage.save(this.tasks);
                console.log(`Removed ${toRemove.length} tasks from category '${categoryId}'.`);
            }

            remove(taskId){
                try {
                    // Simply delete the task - subtasks are nested within it and will be deleted automatically
                    delete this.tasks[taskId];
                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' removed.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on removing task '${taskId}':`, err.message);

                    return false;
                }
            }

            done(taskId){
                try{
                    const task = this.tasks[taskId];
                    this.tasks[taskId]["done"] = true;

                    // Mark all nested subtasks as done too
                    if (task && task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach(subtask => {
                            subtask.done = true;
                            console.log(`Subtask marked as done (cascade from parent task).`);
                        });
                    }

                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' marked as done.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on marking task '${taskId}' as done:`, err.message);

                    return false;
                }
            }

            undone(taskId){
                try{
                    const task = this.tasks[taskId];
                    this.tasks[taskId]["done"] = false;

                    // Mark all nested subtasks as undone too
                    if (task && task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach(subtask => {
                            subtask.done = false;
                            console.log(`Subtask marked as undone (cascade from parent task).`);
                        });
                    }

                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' marked as undone.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on marking task '${taskId}' as undone:`, err.message);

                    return false;
                }
            }

            edit(taskId, newText){
                try{
                    this.tasks[taskId]["task"] = newText;
                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' edited to '${newText}'.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on editing task '${taskId}':`, err.message);

                    return false;
                }
            }

            toggleSubTask(taskId, parentId){
                try{
                    // Find if this task is currently in someone's subtasks array
                    let currentParent = null;
                    let subtaskIndex = -1;

                    for (const [id, t] of Object.entries(this.tasks)) {
                        if (t.subtasks && Array.isArray(t.subtasks)) {
                            const idx = t.subtasks.findIndex(st => st.id === taskId);
                            if (idx !== -1) {
                                currentParent = id;
                                subtaskIndex = idx;
                                break;
                            }
                        }
                    }

                    if (currentParent) {
                        // Task is currently a subtask - promote to root level
                        const subtaskData = this.tasks[currentParent].subtasks[subtaskIndex];
                        this.tasks[currentParent].subtasks.splice(subtaskIndex, 1);

                        // Add as root-level task positioned right after the parent
                        const parentOrder = this.tasks[currentParent].order;

                        // Shift orders of all tasks that come after the parent
                        Object.values(this.tasks).forEach(t => {
                            if (t && typeof t.order === 'number' && t.order > parentOrder) {
                                t.order += 1;
                            }
                        });

                        this.tasks[taskId] = {
                            task: subtaskData.task,
                            done: subtaskData.done,
                            order: parentOrder + 1,
                            subtasks: [],
                            collapsed: false,
                            categoryId: this.tasks[currentParent].categoryId || null  // Inherit parent's category
                        };
                        console.log(`Task '${taskId}' promoted to root level.`);
                    } else {
                        // Task is at root level - demote to subtask of parent
                        if (!parentId || !this.tasks[parentId]) {
                            console.error('No valid parent task found to nest under.');
                            return false;
                        }

                        const task = this.tasks[taskId];
                        if (!task) {
                            console.error('Task not found at root level.');
                            return false;
                        }

                        const taskData = { ...task, id: taskId };
                        delete taskData.order;  // Subtasks don't need order
                        delete taskData.subtasks;  // Subtasks can't have subtasks
                        delete taskData.collapsed;  // Subtasks don't need collapsed state
                        delete taskData.categoryId;  // Subtasks inherit parent's category

                        if (!this.tasks[parentId].subtasks) {
                            this.tasks[parentId].subtasks = [];
                        }
                        this.tasks[parentId].subtasks.push(taskData);

                        delete this.tasks[taskId];  // Remove from root level
                        console.log(`Task '${taskId}' demoted to subtask of '${parentId}'.`);
                    }

                    this.storage.save(this.tasks);
                    return true;
                } catch(err){
                    console.error(`An error occurred on toggling subTask for task '${taskId}':`, err.message);
                    return false;
                }
            }

            render(){
                const todoList = document.getElementById('todo-list');
                const doneList = document.getElementById('done-list');
                const doneSection = document.getElementById('done-section');
                if (!todoList || !doneList) return;

                todoList.innerHTML = '';
                doneList.innerHTML = '';

                // Filter tasks by selected category
                const selectedCategoryId = this.categories ? this.categories.getSelected() : null;
                let entries = (this.tasks && typeof this.tasks === 'object') ? Object.entries(this.tasks) : [];

                // Only filter if a category is selected
                if (selectedCategoryId) {
                    entries = entries.filter(([_, task]) => task.categoryId === selectedCategoryId);
                }

                entries.sort((a,b) => {
                    const ao = (a[1] && typeof a[1].order === 'number') ? a[1].order : 0;
                    const bo = (b[1] && typeof b[1].order === 'number') ? b[1].order : 0;
                    return ao - bo;
                });
                let hasDone = false;

                // Helper: Check if all subtasks are done
                const areAllSubtasksDone = (task) => {
                if (!task.subtasks || task.subtasks.length === 0) return true;
                return task.subtasks.every(st => st.done);
            };

                // Helper: Find parent task ID for a given task (searches subtasks arrays)
                const findParentId = (targetId) => {
                for (const [id, task] of entries) {
            if (task.subtasks && task.subtasks.some(st => st.id === targetId)) {
                return id;
            }
            }
                return null;
            };

                // Helper function to create a task row (works for both parent and subtask)
                const createTaskRow = (taskId, taskData, isSubtask, parentId, isFirstRootTask = false) => {
                const row = document.createElement('div');
            row.className = 'task-row';
            row.dataset.id = taskId;
                if (parentId) row.dataset.parentId = parentId;

                // Add indentation for subtasks (includes space for toggle button + standard indent)
                if (isSubtask) {
            row.classList.add('subtask-row');
            }

                const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = !!taskData.done;
                if (isSubtask) {
            checkbox.classList.add('subtask-checkbox');
            }
            checkbox.addEventListener('change', () => {
            if (!isSubtask) {
                // Parent task checkbox
                if (checkbox.checked) {
                    this.done(taskId);
                } else {
                    this.undone(taskId);
                }
            } else {
                // Subtask checkbox - update within parent's subtasks array
                const parent = this.tasks[parentId];
                if (parent) {
                    const subtask = parent.subtasks.find(st => st.id === taskId);
                    if (subtask) {
                        subtask.done = checkbox.checked;

                        // If subtask is unchecked, uncheck the parent too
                        if (!checkbox.checked && parent.done) {
                            parent.done = false;
                        }

                        this.storage.save(this.tasks);
                    }
                }
            }
            setTimeout(() => this.render(), 140);
            });

                const text = document.createElement('span');
            text.textContent = ` ${taskData.task} `;
                if (isSubtask) {
            text.classList.add('subtask-text');
            }

                const editBtn = document.createElement('button');
            editBtn.textContent = 'ðŸ–‹';
            editBtn.setAttribute('aria-label', 'Edit task');
            editBtn.setAttribute('title', 'Edit task');
            editBtn.classList.add('task-action-btn');
            editBtn.addEventListener('click', () => {
            // Create edit container
            const editContainer = document.createElement('div');
            editContainer.className = 'task-edit-container';

            const editInput = document.createElement('input');
            editInput.type = 'text';
            editInput.value = taskData.task;

            // Create category dropdown (only for parent tasks)
            let categorySelect = null;
            if (!isSubtask && this.categories) {
                categorySelect = document.createElement('select');
                categorySelect.className = 'task-category-select';

                // Add "Uncategorized" option
                const uncatOption = document.createElement('option');
                uncatOption.value = '';
                uncatOption.textContent = 'Uncategorized';
                categorySelect.appendChild(uncatOption);

                // Add all categories
                const sortedCategories = this.categories.getSorted();
                for (const [catId, cat] of sortedCategories) {
                    const option = document.createElement('option');
                    option.value = catId;
                    option.textContent = cat.name;
                    if (catId === taskData.categoryId) {
                        option.selected = true;
                    }
                    categorySelect.appendChild(option);
                }

                // If task has no category, select "Uncategorized"
                if (!taskData.categoryId) {
                    categorySelect.value = '';
                }
            }

            // Save on Enter key press
            const saveEdit = () => {
                const newText = (editInput.value || '').trim();
                if (newText) {
                    if (!isSubtask) {
                        if (this.edit(taskId, newText)) {
                            // Also update category if changed
                            if (categorySelect) {
                                const newCategoryId = categorySelect.value || null;
                                this.tasks[taskId].categoryId = newCategoryId;
                                // Ensure all subtasks inherit parent's category (clear any old categoryId)
                                if (this.tasks[taskId].subtasks) {
                                    this.tasks[taskId].subtasks.forEach(st => {
                                        delete st.categoryId;
                                    });
                                }
                                this.storage.save(this.tasks);
                            }
                            this.render();
                        }
                    } else {
                        // Update subtask text
                        const parent = this.tasks[parentId];
                        if (parent) {
                            const subtask = parent.subtasks.find(st => st.id === taskId);
                            if (subtask) {
                                subtask.task = newText;
                                this.storage.save(this.tasks);
                                this.render();
                            }
                        }
                    }
                }
            };

            editInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') saveEdit();
                if (e.key === 'Escape') this.render();
            });

            if (categorySelect) {
                categorySelect.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') saveEdit();
                    if (e.key === 'Escape') this.render();
                });
            }

            editContainer.appendChild(editInput);
            if (categorySelect) {
                editContainer.appendChild(categorySelect);
            }

            row.replaceChild(editContainer, text);

            // Add editing class to row (hides category tag via CSS)
            row.classList.add('editing');

            editInput.focus();
            editInput.select();
            });

                // Add subtask toggle button (for converting to/from subtask)
                // Only show if: it's a subtask OR it's a parent task WITHOUT subtasks
                const subTaskToggleBtn = document.createElement('button');
                subTaskToggleBtn.textContent = isSubtask ? 'â¤¶' : 'â¤·';
                subTaskToggleBtn.className = 'subtask-edit-toggle';
                subTaskToggleBtn.setAttribute('aria-label', 'Toggle subtask mode');
                subTaskToggleBtn.setAttribute('title', 'Toggle subtask mode');

                // Hide button for parent tasks with subtasks OR if it's the first root task
                if ((!isSubtask && taskData.subtasks && taskData.subtasks.length > 0) || (!isSubtask && isFirstRootTask)) {
                    subTaskToggleBtn.classList.add('hidden');
                }

                if (isSubtask) {
                    subTaskToggleBtn.classList.add('active');
                }
                subTaskToggleBtn.addEventListener('click', () => {
                    setTimeout(() => {
                        // Toggle between subtask and parent
                        if (isSubtask) {
                            this.toggleSubTask(taskId, null); // Promote to root
                        } else {
                            // Find the previous task to use as parent
                            const allRows = Array.from(todoList.querySelectorAll('.task-row'));
                            const currentIndex = allRows.findIndex(r => r.dataset.id === taskId);
                            if (currentIndex > 0) {
                                const prevRow = allRows[currentIndex - 1];
                                const prevId = prevRow.dataset.parentId || prevRow.dataset.id;
                                this.toggleSubTask(taskId, prevId); // Demote to subtask
                            }
                        }
                        this.render();
                    }, 300);
                });

                const removeBtn = document.createElement('button');
            removeBtn.textContent = 'ðŸ—‘';
            removeBtn.setAttribute('aria-label', 'Remove task');
            removeBtn.setAttribute('title', 'Remove task');
            removeBtn.classList.add('task-action-btn');
            removeBtn.addEventListener('click', () => {
            if (!isSubtask) {
                this.remove(taskId);
            } else {
                // Remove subtask from parent's array
                const parent = this.tasks[parentId];
                if (parent) {
                    parent.subtasks = parent.subtasks.filter(st => st.id !== taskId);
                    this.storage.save(this.tasks);
                }
            }
            this.render();
            });

            // Add toggle button only for parent tasks that have subtasks
            if (!isSubtask && taskData.subtasks && taskData.subtasks.length > 0) {
                const toggleBtn = document.createElement('button');
                toggleBtn.textContent = 'â–¸';
                toggleBtn.className = 'subtask-toggle';
                toggleBtn.setAttribute('aria-label', 'Toggle subtasks');
                toggleBtn.setAttribute('title', 'Toggle subtasks');

                if (!taskData.collapsed) {
                    toggleBtn.classList.add('expanded');
                }

                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const task = this.tasks[taskId];
                    if (task) {
                        const isCurrentlyCollapsed = task.collapsed;

                        // Toggle the rotation class immediately for smooth animation
                        toggleBtn.classList.toggle('expanded');

                        if (!isCurrentlyCollapsed) {
                            // Collapsing: animate subtasks out first
                            const subtaskRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
                            subtaskRows.forEach(subtaskRow => {
                                subtaskRow.classList.add('subtask-collapsing');
                            });

                            setTimeout(() => {
                                task.collapsed = true;
                                this.storage.save(this.tasks);
                                this.render();
                            }, 300);
                        } else {
                            // Expanding: update state and render, then animate in
                            task.collapsed = false;
                            this.storage.save(this.tasks);
                            this.render();

                            // After render, animate the newly visible subtasks
                            requestAnimationFrame(() => {
                                const subtaskRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
                                subtaskRows.forEach(subtaskRow => {
                                    // Start with collapsed state
                                    subtaskRow.classList.add('subtask-collapsing');

                                    // Force a reflow
                                    subtaskRow.offsetHeight;

                                    // Add transition class and remove collapsed state
                                    subtaskRow.classList.add('subtask-expanding');
                                    subtaskRow.classList.remove('subtask-collapsing');
                                });
                            });
                        }
                    }
                });

                row.appendChild(toggleBtn);
            }

            row.appendChild(checkbox);
            row.appendChild(text);

            // Add category tag when viewing "All" (no category filter)
            if (!selectedCategoryId && !isSubtask && taskData.categoryId) {
                const categoryName = this.categories ? this.categories.getNameById(taskData.categoryId) : null;
                if (categoryName) {
                    const categoryTag = document.createElement('span');
                    categoryTag.className = 'task-category-tag';
                    categoryTag.textContent = categoryName;
                    row.appendChild(categoryTag);
                }
            }

            // Move up button
            const moveUpBtn = document.createElement('button');
            moveUpBtn.textContent = 'â¬†';
            moveUpBtn.setAttribute('aria-label', 'Move up');
            moveUpBtn.setAttribute('title', 'Move up');
            moveUpBtn.classList.add('task-move-btn');
            moveUpBtn.addEventListener('click', () => {
                if (!isSubtask) {
                    // Move parent task up
                    const sortedTasks = Object.entries(this.tasks)
                        .filter(([_, t]) => t.categoryId === taskData.categoryId || (!selectedCategoryId))
                        .sort((a, b) => (a[1].order || 0) - (b[1].order || 0));
                    const currentIndex = sortedTasks.findIndex(([id]) => id === taskId);
                    if (currentIndex > 0) {
                        const prevTaskId = sortedTasks[currentIndex - 1][0];
                        const currentOrder = this.tasks[taskId].order;
                        this.tasks[taskId].order = this.tasks[prevTaskId].order;
                        this.tasks[prevTaskId].order = currentOrder;
                        this.storage.save(this.tasks);
                        this.render();
                    }
                } else {
                    // Move subtask up within parent
                    const parent = this.tasks[parentId];
                    if (parent && parent.subtasks) {
                        const currentIndex = parent.subtasks.findIndex(st => st.id === taskId);
                        if (currentIndex > 0) {
                            [parent.subtasks[currentIndex - 1], parent.subtasks[currentIndex]] =
                                [parent.subtasks[currentIndex], parent.subtasks[currentIndex - 1]];
                            this.storage.save(this.tasks);
                            this.render();
                        }
                    }
                }
            });

            // Move down button
            const moveDownBtn = document.createElement('button');
            moveDownBtn.textContent = 'â¬‡';
            moveDownBtn.setAttribute('aria-label', 'Move down');
            moveDownBtn.setAttribute('title', 'Move down');
            moveDownBtn.classList.add('task-move-btn');
            moveDownBtn.addEventListener('click', () => {
                if (!isSubtask) {
                    // Move parent task down
                    const sortedTasks = Object.entries(this.tasks)
                        .filter(([_, t]) => t.categoryId === taskData.categoryId || (!selectedCategoryId))
                        .sort((a, b) => (a[1].order || 0) - (b[1].order || 0));
                    const currentIndex = sortedTasks.findIndex(([id]) => id === taskId);
                    if (currentIndex < sortedTasks.length - 1) {
                        const nextTaskId = sortedTasks[currentIndex + 1][0];
                        const currentOrder = this.tasks[taskId].order;
                        this.tasks[taskId].order = this.tasks[nextTaskId].order;
                        this.tasks[nextTaskId].order = currentOrder;
                        this.storage.save(this.tasks);
                        this.render();
                    }
                } else {
                    // Move subtask down within parent
                    const parent = this.tasks[parentId];
                    if (parent && parent.subtasks) {
                        const currentIndex = parent.subtasks.findIndex(st => st.id === taskId);
                        if (currentIndex < parent.subtasks.length - 1) {
                            [parent.subtasks[currentIndex], parent.subtasks[currentIndex + 1]] =
                                [parent.subtasks[currentIndex + 1], parent.subtasks[currentIndex]];
                            this.storage.save(this.tasks);
                            this.render();
                        }
                    }
                }
            });

            row.appendChild(subTaskToggleBtn);
            row.appendChild(moveUpBtn);
            row.appendChild(moveDownBtn);
            row.appendChild(editBtn);
            row.appendChild(removeBtn);

                return row;
            };

                // Render all tasks
                let firstRootTaskRendered = false;
                for (const [taskId, task] of entries){
                // Determine if task group should be in Done section
                const allDone = task.done && areAllSubtasksDone(task);

                if (allDone) {
            // Parent and all subtasks go to Done
            hasDone = true;
            const parentRow = createTaskRow(taskId, task, false, null, false);
            doneList.appendChild(parentRow);

            // Render subtasks in Done (only if not collapsed)
            if (task.subtasks && task.subtasks.length > 0 && !task.collapsed) {
                task.subtasks.forEach(subtask => {
                    const subtaskRow = createTaskRow(subtask.id, subtask, true, taskId, false);
                    doneList.appendChild(subtaskRow);
                });
            }
            } else {
            // Parent and subtasks stay in To Do
            const isFirstRootTask = !firstRootTaskRendered;
            firstRootTaskRendered = true;
            const parentRow = createTaskRow(taskId, task, false, null, isFirstRootTask);
            todoList.appendChild(parentRow);
            parentRow.draggable = true;

            // Add drag-and-drop for parent tasks
            parentRow.addEventListener('dragstart', (e) => {
                this.draggingId = taskId;
                parentRow.classList.add('dragging');
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', taskId);
                }
            });
            parentRow.addEventListener('dragend', () => {
                parentRow.classList.remove('dragging');
                this.draggingId = null;
                const orderIds = Array.from(todoList.querySelectorAll('.task-row[data-parent-id=""],.task-row:not([data-parent-id])')).map(el => el.dataset.id);
                orderIds.forEach((id, idx) => { if (this.tasks[id]) this.tasks[id].order = idx; });
                this.storage.save(this.tasks);
                this.render();
            });

            // Render subtasks (only if not collapsed)
            if (task.subtasks && task.subtasks.length > 0 && !task.collapsed) {
                task.subtasks.forEach((subtask, subIndex) => {
                    const subtaskRow = createTaskRow(subtask.id, subtask, true, taskId, false);
                    todoList.appendChild(subtaskRow);
                    subtaskRow.draggable = true;

                    // Add drag-and-drop for subtasks
                    subtaskRow.addEventListener('dragstart', (e) => {
                        this.draggingId = subtask.id;
                        this.draggingParentId = taskId;
                        subtaskRow.classList.add('dragging');
                        if (e.dataTransfer) {
                            e.dataTransfer.effectAllowed = 'move';
                            e.dataTransfer.setData('text/plain', subtask.id);
                        }
                    });

                    subtaskRow.addEventListener('dragend', () => {
                        subtaskRow.classList.remove('dragging');

                        // Reorder subtasks based on DOM order
                        const parentTask = this.tasks[taskId];
                        if (parentTask) {
                            const subtaskElements = Array.from(todoList.querySelectorAll(`[data-parent-id="${taskId}"]`));
                            const newOrder = subtaskElements.map(el => el.dataset.id);

                            // Reorder the subtasks array
                            const reorderedSubtasks = [];
                            newOrder.forEach(subId => {
                                const sub = parentTask.subtasks.find(s => s.id === subId);
                                if (sub) reorderedSubtasks.push(sub);
                            });

                            parentTask.subtasks = reorderedSubtasks;
                            this.storage.save(this.tasks);
                        }

                        this.draggingId = null;
                        this.draggingParentId = null;
                        this.render();
                    });
                });
            }
            }
            }

                // Drag helper function
                const getDragAfterElement = (container, y) => {
                const els = [...container.querySelectorAll('.task-row:not(.dragging):not([data-parent-id])')];
                return els.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset, element: child };
            } else {
                return closest;
            }
            }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
            };

                // Dragover handler
                todoList.addEventListener('dragover', (e) => {
            e.preventDefault();
                const dragging = todoList.querySelector('.task-row.dragging');
                if (!dragging) return;

                // Check if dragging a subtask
                if (this.draggingParentId) {
                    // Handle subtask reordering
                    const subtasks = Array.from(todoList.querySelectorAll(`[data-parent-id="${this.draggingParentId}"]`));

                    // Find which subtask is under the cursor
                    let targetSubtask = null;
                    for (const sub of subtasks) {
                        if (sub === dragging) continue;
                        const box = sub.getBoundingClientRect();
                        if (e.clientY >= box.top && e.clientY <= box.bottom) {
                            targetSubtask = sub;
                            break;
                        }
                    }

                    if (targetSubtask) {
                        const box = targetSubtask.getBoundingClientRect();
                        const offset = e.clientY - box.top - box.height / 2;

                        if (offset < 0) {
                            todoList.insertBefore(dragging, targetSubtask);
                        } else {
                            todoList.insertBefore(dragging, targetSubtask.nextSibling);
                        }
                    }
                    return;
                }

                // Handle parent task reordering
                const rows = Array.from(todoList.querySelectorAll('.task-row:not([data-parent-id])'));
                const prev = new Map(rows.map(el => [el.dataset.id, el.getBoundingClientRect().top]));

                const afterElement = getDragAfterElement(todoList, e.clientY);
                if (afterElement == null) {
            todoList.appendChild(dragging);
            } else {
            todoList.insertBefore(dragging, afterElement);
            }

                const newRows = Array.from(todoList.querySelectorAll('.task-row:not([data-parent-id])'));
            newRows.forEach(el => {
            if (el === dragging) return;
            const oldTop = prev.get(el.dataset.id);
            if (oldTop == null) return;
            const newTop = el.getBoundingClientRect().top;
            const dy = oldTop - newTop;
            if (dy !== 0) {
                el.classList.add('drag-no-animate');
                el.style.transform = `translateY(${dy}px)`;
                requestAnimationFrame(() => {
                    el.classList.remove('drag-no-animate');
                    el.classList.add('drag-animate');
                    el.style.transform = '';
                });
            }
            });
            });

                if (doneSection) doneSection.classList.toggle('hidden', !hasDone);
            }
        }

        class Theme {
            constructor(toggleEl){
                this.toggleEl = toggleEl;
                this.storage = new JsonStorage('theme');
            }
            apply(mode){
                document.body.setAttribute('data-theme', mode);
                document.documentElement.setAttribute('data-theme', mode);
                if (this.toggleEl) this.toggleEl.textContent = mode === 'dark' ? 'â˜€' : 'â˜½';
                this.storage.save(mode);
            }
            init(){
                const saved = this.storage.load() || 'light';
                this.apply(saved);
                if (this.toggleEl) {
                    this.toggleEl.addEventListener('click', () => {
                        const next = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                        this.apply(next);
                    });
                }
            }
        }

        class FileManager {
            constructor(app, categories, modal, fileInput, cancelBtn, confirmBtn){
                this.app = app;
                this.categories = categories;
                this.modal = modal;
                this.fileInput = fileInput;
                this.cancelBtn = cancelBtn;
                this.confirmBtn = confirmBtn;
                this.pendingData = null;
            }

            exportToFile(){
                try {
                    const exportData = {
                        tasks: this.app.tasks || {},
                        categories: this.categories.categories || {}
                    };
                    const data = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const date = new Date().toISOString().slice(0, 10);
                    a.download = `simpletask-${date}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log('Tasks and categories exported successfully.');
                } catch (err) {
                    console.error('Export failed:', err);
                }
            }

            openModal(){
                if (!this.modal) return;
                this.pendingData = null;
                if (this.fileInput) this.fileInput.value = '';
                if (this.confirmBtn) this.confirmBtn.disabled = true;
                this.modal.classList.add('open');
                this.modal.setAttribute('aria-hidden', 'false');
            }

            closeModal(){
                if (!this.modal) return;
                this.modal.classList.remove('open');
                this.modal.setAttribute('aria-hidden', 'true');
                this.pendingData = null;
                if (this.fileInput) this.fileInput.value = '';
                if (this.confirmBtn) this.confirmBtn.disabled = true;
            }

            handleFileSelect(file){
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        if (!parsed || typeof parsed !== 'object') {
                            throw new Error('Invalid data format');
                        }
                        this.pendingData = parsed;
                        if (this.confirmBtn) this.confirmBtn.disabled = false;
                        console.log('File parsed successfully, ready to import.');
                    } catch (err) {
                        console.error('Invalid JSON file:', err);
                        this.pendingData = null;
                        if (this.confirmBtn) this.confirmBtn.disabled = true;
                        alert('Invalid JSON file. Please select a valid SimpleTask export file.');
                    }
                };
                reader.onerror = () => {
                    console.error('Failed to read file');
                    this.pendingData = null;
                    if (this.confirmBtn) this.confirmBtn.disabled = true;
                };
                reader.readAsText(file);
            }

            confirmImport(){
                if (!this.pendingData) return;

                // Handle new format (with tasks and categories) or old format (tasks only)
                if (this.pendingData.tasks && typeof this.pendingData.tasks === 'object') {
                    // New format
                    this.app.tasks = this.pendingData.tasks;
                    this.app.storage.save(this.app.tasks);

                    if (this.pendingData.categories && typeof this.pendingData.categories === 'object') {
                        this.categories.categories = this.pendingData.categories;
                        this.categories.storage.save(this.categories.categories);
                        // Reset selected category to "All"
                        this.categories.select(null);
                    }
                    console.log('Tasks and categories imported successfully.');
                } else {
                    // Old format (backward compatibility)
                    this.app.tasks = this.pendingData;
                    this.app.storage.save(this.app.tasks);
                    console.log('Tasks imported successfully (legacy format).');
                }

                this.closeModal();
                this.categories.render(
                    document.getElementById('category-tabs'),
                    document.getElementById('delete-category-modal'),
                    document.getElementById('delete-category-name')
                );
                this.app.render();
            }

            init(){
                if (this.fileInput) {
                    this.fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) this.handleFileSelect(file);
                    });
                }
                if (this.cancelBtn) {
                    this.cancelBtn.addEventListener('click', () => this.closeModal());
                }
                if (this.confirmBtn) {
                    this.confirmBtn.addEventListener('click', () => this.confirmImport());
                }
                if (this.modal) {
                    this.modal.addEventListener('click', (e) => {
                        if (e.target === this.modal) this.closeModal();
                    });
                }
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.closeModal();
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Category elements
            const categoryTabs = document.getElementById('category-tabs');
            const addCategoryBtn = document.getElementById('add-category');
            const deleteCategoryModal = document.getElementById('delete-category-modal');
            const deleteCategoryName = document.getElementById('delete-category-name');
            const cancelDeleteCategory = document.getElementById('cancel-delete-category');
            const confirmDeleteCategory = document.getElementById('confirm-delete-category');

            // Initialize Categories first (app will use it for filtering)
            let app; // Forward declaration
            const categories = new Categories(() => {
                if (app) app.render();
                categories.render(categoryTabs, deleteCategoryModal, deleteCategoryName);
            });

            // Initialize Tasks with categories reference
            app = new Tasks(categories);

            // Add category button
            if (addCategoryBtn) {
                addCategoryBtn.addEventListener('click', () => {
                    const name = prompt('Enter category name:');
                    if (name && name.trim()) {
                        if (categories.add(name.trim())) {
                            categories.render(categoryTabs, deleteCategoryModal, deleteCategoryName);
                            app.render();
                        }
                    }
                });
            }

            // Delete category modal handlers
            const closeDeleteModal = () => {
                if (deleteCategoryModal) {
                    deleteCategoryModal.classList.remove('open');
                    deleteCategoryModal.setAttribute('aria-hidden', 'true');
                }
                categories.pendingDeleteId = null;
            };

            if (cancelDeleteCategory) {
                cancelDeleteCategory.addEventListener('click', closeDeleteModal);
            }

            if (confirmDeleteCategory) {
                confirmDeleteCategory.addEventListener('click', () => {
                    if (categories.pendingDeleteId) {
                        // Delete all tasks in this category
                        app.removeByCategory(categories.pendingDeleteId);
                        // Delete the category
                        categories.remove(categories.pendingDeleteId);
                        categories.render(categoryTabs, deleteCategoryModal, deleteCategoryName);
                        app.render();
                    }
                    closeDeleteModal();
                });
            }

            if (deleteCategoryModal) {
                deleteCategoryModal.addEventListener('click', (e) => {
                    if (e.target === deleteCategoryModal) closeDeleteModal();
                });
            }

            const addInput = document.getElementById('new-task');
            if (addInput) {
                addInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const text = (addInput.value || '').trim();
                        if (!text) return;
                        app.tasks = app.tasks || {};
                        if (app.add(text)) {
                            addInput.value = '';
                            app.render();
                        }
                    }
                });
            }

            const themeToggle = document.getElementById('theme-toggle');
            const theme = new Theme(themeToggle);
            theme.init();

            const importBtn = document.getElementById('import-tasks');
            const exportBtn = document.getElementById('export-tasks');
            const modal = document.getElementById('import-modal');
            const fileInput = document.getElementById('import-file');
            const cancelBtn = document.getElementById('cancel-import');
            const confirmBtn = document.getElementById('confirm-import');
            const fileManager = new FileManager(app, categories, modal, fileInput, cancelBtn, confirmBtn);
            fileManager.init();
            if (importBtn) importBtn.addEventListener('click', () => fileManager.openModal());
            if (exportBtn) exportBtn.addEventListener('click', () => fileManager.exportToFile());

            // Initial render
            categories.render(categoryTabs, deleteCategoryModal, deleteCategoryName);
            app.render();

            // Register Service Worker for PWA/offline support
            if ('serviceWorker' in navigator) {
                const scope = '/simple_task/';
                navigator.serviceWorker.register('sw.js', { scope }).catch(err => {
                    console.warn('SW registration failed:', err);
                });
            }

            // Minimal Install Banner (Android/desktop with beforeinstallprompt)
            const installBanner = document.getElementById('install-banner');
            const installBtn = document.getElementById('install-cta');
            const installClose = document.getElementById('install-close');
            let deferredPrompt = null;

            const isStandalone = () => window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
            const isMobile = () => (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            const showInstallBanner = () => {
                if (!installBanner) return;
                installBanner.classList.add('show');
                installBanner.setAttribute('aria-hidden', 'false');
            };
            const hideInstallBanner = () => {
                if (!installBanner) return;
                installBanner.classList.remove('show');
                installBanner.setAttribute('aria-hidden', 'true');
            };

            window.addEventListener('beforeinstallprompt', (e) => {
                // Only show on mobile, not if already installed, and not if dismissed
                if (isStandalone() || !isMobile() || localStorage.getItem('installBannerDismissed') === '1') return;
                e.preventDefault();
                deferredPrompt = e;
                showInstallBanner();
            });
            window.addEventListener('appinstalled', () => {
                deferredPrompt = null;
                hideInstallBanner();
                localStorage.setItem('installBannerDismissed', '1');
            });
            if (installBtn) installBtn.addEventListener('click', async () => {
                try {
                    if (!deferredPrompt) return hideInstallBanner();
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    deferredPrompt = null;
                    hideInstallBanner();
                    if (outcome !== 'accepted') localStorage.setItem('installBannerDismissed', '1');
                } catch (_) { hideInstallBanner(); }
            });
            if (installClose) installClose.addEventListener('click', () => {
                localStorage.setItem('installBannerDismissed', '1');
                hideInstallBanner();
            });
        });
    </script>
    </body>
</html>
