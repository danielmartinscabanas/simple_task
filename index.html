<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='52'%3E%E2%9C%85%3C/text%3E%3C/svg%3E">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#349a79">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Tasks</title>
</head>
<body>
    <div class="page-header">
        <h2>Tasks</h2>
        <div class="header-actions">
            <button id="export-tasks" aria-label="Export tasks" title="Export tasks">â†—</button>
            <button id="theme-toggle" aria-label="Toggle theme" title="Toggle theme">â˜½</button>
        </div>
    </div>
    <section id="todo-section">
        <h3>To do</h3>
        <hr />
        <div id="todo-list"></div>
        <input id="new-task" type="text" placeholder="New task" />
    </section>

    <section id="done-section">
        <h3>Done</h3>
        <hr />
        <div id="done-list"></div>
    </section>
    <!-- Share URL Modal -->
    <div id="export-modal" class="modal" aria-hidden="true" role="dialog">
        <div class="modal-card" role="document">
            <div class="modal-title">Share URL</div>
            <div class="modal-row">
                <input id="share-url" type="text" readonly aria-label="Share URL" />
                <div class="modal-actions">
                    <button id="copy-url" aria-label="Copy URL" title="Copy URL"><img src="copy-icon.svg" alt="" class="icon-img" /></button>
                    <button id="close-modal" aria-label="Close" title="Close">âœ•</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Minimal Install Banner (mobile only) -->
    <div id="install-banner" class="install-banner" aria-hidden="true">
        <span>Install app?</span>
        <button id="install-cta" aria-label="Install app" title="Install">Install</button>
        <button id="install-close" aria-label="Dismiss" title="Dismiss">âœ•</button>
    </div>
    <script>
        class JsonStorage {
            constructor(storageKey){
                this.storageKey = storageKey;
            }

            save(dataObject){
                localStorage.setItem(this.storageKey, JSON.stringify(dataObject));
            }

            load(){
                const json = localStorage.getItem(this.storageKey);
                return json ? JSON.parse(json) : null;
            }

            remove(){
                localStorage.removeItem(this.storageKey);
            }
        }
    
        class Tasks{
            constructor(){
                this.storage = new JsonStorage('tasks');
                this.tasks = this.storage.load();
                this.draggingId = null;
            }

            add(text){
                try{
                    const taskId = crypto.randomUUID();
                    const existing = this.tasks || {};
                    const maxOrder = Math.max(-1, ...Object.values(existing).map(t => (t && typeof t.order === 'number') ? t.order : -1));
                    const newTask = {"task": text, "done": false, "order": maxOrder + 1};
                    this.tasks[taskId] = newTask;
                    this.storage.save(this.tasks);
                    console.log(`Task '${text}' created.`);

                    return true;

                } catch(err){
                    console.error(`An error ocurred on creating task '${text}':`, err.message);

                    return false;
                }
            }

            remove(taskId){
                try {
                    delete this.tasks[taskId];
                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' removed.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on removing task '${taskId}':`, err.message);

                    return false;
                }
            }

            done(taskId){
                try{
                    this.tasks[taskId]["done"] = true;
                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' marked as done.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on marking task '${taskId}' as done:`, err.message);

                    return false;
                }
            }

            undone(taskId){
                try{
                    this.tasks[taskId]["done"] = false;
                    this.storage.save(this.tasks);
                    console.log(`Task '${taskId}' marked as undone.`);

                    return true;
                } catch(err){
                    console.error(`An error ocurred on marking task '${taskId}' as undone:`, err.message);

                    return false;
                }
            }

            render(){
                const todoList = document.getElementById('todo-list');
                const doneList = document.getElementById('done-list');
                const doneSection = document.getElementById('done-section');
                if (!todoList || !doneList) return;

                todoList.innerHTML = '';
                doneList.innerHTML = '';

                const entries = (this.tasks && typeof this.tasks === 'object') ? Object.entries(this.tasks) : [];
                entries.sort((a,b) => {
                    const ao = (a[1] && typeof a[1].order === 'number') ? a[1].order : 0;
                    const bo = (b[1] && typeof b[1].order === 'number') ? b[1].order : 0;
                    return ao - bo;
                });
                let hasDone = false;

                for (const [taskId, item] of entries){
                    const row = document.createElement('div');
                    row.className = 'task-row';
                    row.dataset.id = taskId;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = !!item.done;
                    checkbox.addEventListener('change', () => {
                        if (checkbox.checked) {
                            this.done(taskId);
                        } else {
                            this.undone(taskId);
                        }
                        setTimeout(() => this.render(), 140);
                    });

                    const text = document.createElement('span');
                    text.textContent = ` ${item.task} `;

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'ðŸ—‘';
                    removeBtn.setAttribute('aria-label', 'Remove task');
                    removeBtn.setAttribute('title', 'Remove task');
                    removeBtn.addEventListener('click', () => {
                        this.remove(taskId);
                        this.render();
                    });

                    row.appendChild(checkbox);
                    row.appendChild(text);
                    row.appendChild(removeBtn);

                    if (item.done) {
                        hasDone = true;
                        doneList.appendChild(row);
                    } else {
                        row.draggable = true;
                        row.addEventListener('dragstart', (e) => {
                            this.draggingId = taskId;
                            row.classList.add('dragging');
                            if (e.dataTransfer) {
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/plain', taskId);
                            }
                        });
                        row.addEventListener('dragend', () => {
                            row.classList.remove('dragging');
                            this.draggingId = null;
                            const orderIds = Array.from(todoList.querySelectorAll('.task-row')).map(el => el.dataset.id);
                            orderIds.forEach((id, idx) => { if (this.tasks[id]) this.tasks[id].order = idx; });
                            this.storage.save(this.tasks);
                            this.render();
                        });
                        // Pointer-based drag with long-press + move tolerance (mobile/touch)
                        row.addEventListener('pointerdown', (e) => {
                            const tag = (e.target && e.target.tagName || '').toLowerCase();
                            if (tag === 'input' || tag === 'button') return;
                            if (e.pointerType === 'mouse') return; // desktop uses native DnD

                            const HOLD_MS = 150;
                            const TOL = 8; // px movement allowed before starting
                            const startX = e.clientX;
                            const startY = e.clientY;
                            let started = false;
                            // Capture pointer early so we continue receiving moves
                            try { row.setPointerCapture && row.setPointerCapture(e.pointerId); } catch (_) {}
                            let holdTimer = setTimeout(() => {
                                started = true;
                                this.draggingId = taskId;
                                row.classList.add('dragging');
                                row.style.touchAction = 'none';
                            }, HOLD_MS);

                            const onMove = (ev) => {
                                if (!started) {
                                    const dx = (ev.clientX ?? startX) - startX;
                                    const dy = (ev.clientY ?? startY) - startY;
                                    if (Math.hypot(dx, dy) > TOL) {
                                        clearTimeout(holdTimer); holdTimer = null;
                                        // user is scrolling; release capture and stop tracking
                                        try { row.releasePointerCapture && row.releasePointerCapture(e.pointerId); } catch (_) {}
                                        window.removeEventListener('pointermove', onMove, true);
                                        window.removeEventListener('pointerup', onUp, true);
                                        window.removeEventListener('pointercancel', onUp, true);
                                    }
                                    return;
                                }
                                // Actively dragging
                                ev.preventDefault && ev.preventDefault();
                                const dragging = row;
                                const rows = Array.from(todoList.querySelectorAll('.task-row'));
                                const prev = new Map(rows.map(el => [el.dataset.id, el.getBoundingClientRect().top]));
                                const afterElement = getDragAfterElement(todoList, ev.clientY);
                                if (afterElement == null) {
                                    todoList.appendChild(dragging);
                                } else if (afterElement !== dragging) {
                                    todoList.insertBefore(dragging, afterElement);
                                }
                                const newRows = Array.from(todoList.querySelectorAll('.task-row'));
                                newRows.forEach(el => {
                                    if (el === dragging) return;
                                    const oldTop = prev.get(el.dataset.id);
                                    if (oldTop == null) return;
                                    const newTop = el.getBoundingClientRect().top;
                                    const dy2 = oldTop - newTop;
                                    if (dy2 !== 0) {
                                        el.style.transition = 'none';
                                        el.style.transform = `translateY(${dy2}px)`;
                                        requestAnimationFrame(() => {
                                            el.style.transition = 'transform 150ms ease';
                                            el.style.transform = '';
                                        });
                                    }
                                });
                            };
                            const onUp = () => {
                                if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
                                if (started) {
                                    row.classList.remove('dragging');
                                    this.draggingId = null;
                                    row.style.touchAction = '';
                                    const orderIds = Array.from(todoList.querySelectorAll('.task-row')).map(el => el.dataset.id);
                                    orderIds.forEach((id, idx) => { if (this.tasks[id]) this.tasks[id].order = idx; });
                                    this.storage.save(this.tasks);
                                    this.render();
                                }
                                window.removeEventListener('pointermove', onMove, true);
                                window.removeEventListener('pointerup', onUp, true);
                                window.removeEventListener('pointercancel', onUp, true);
                            };
                            window.addEventListener('pointermove', onMove, { capture: true, passive: false });
                            window.addEventListener('pointerup', onUp, true);
                            window.addEventListener('pointercancel', onUp, true);
                        });
                        todoList.appendChild(row);
                    }
                }
                const getDragAfterElement = (container, y) => {
                    const els = [...container.querySelectorAll('.task-row:not(.dragging)')];
                    return els.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
                };
                todoList.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const dragging = todoList.querySelector('.task-row.dragging');
                    if (!dragging) return;

                    const rows = Array.from(todoList.querySelectorAll('.task-row'));
                    const prev = new Map(rows.map(el => [el.dataset.id, el.getBoundingClientRect().top]));

                    const afterElement = getDragAfterElement(todoList, e.clientY);
                    if (afterElement == null) {
                        todoList.appendChild(dragging);
                    } else {
                        todoList.insertBefore(dragging, afterElement);
                    }

                    const newRows = Array.from(todoList.querySelectorAll('.task-row'));
                    newRows.forEach(el => {
                        if (el === dragging) return;
                        const oldTop = prev.get(el.dataset.id);
                        if (oldTop == null) return;
                        const newTop = el.getBoundingClientRect().top;
                        const dy = oldTop - newTop;
                        if (dy !== 0) {
                            el.style.transition = 'none';
                            el.style.transform = `translateY(${dy}px)`;
                            requestAnimationFrame(() => {
                                el.style.transition = 'transform 150ms ease';
                                el.style.transform = '';
                            });
                        }
                    });
                });
                if (doneSection) doneSection.style.display = hasDone ? '' : 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // URL-safe Base64 and LZW compression helpers
            const bytesToBase64Url = (bytes) => {
                let binary = '';
                for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
                return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
            };
            const base64UrlToBytes = (b64url) => {
                let b64 = (b64url || '').replace(/-/g, '+').replace(/_/g, '/');
                while (b64.length % 4) b64 += '=';
                const binary = atob(b64);
                const out = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) out[i] = binary.charCodeAt(i);
                return out;
            };
            // LZW (12-bit) compression over UTF-8 bytes
            const lzwCompress = (bytes) => {
                const CLEAR = 4095;
                let dict = new Map();
                for (let i = 0; i < 256; i++) dict.set(String.fromCharCode(i), i);
                let dictSize = 256;
                let w = '';
                const codes = [];
                for (let i = 0; i < bytes.length; i++) {
                    const c = String.fromCharCode(bytes[i]);
                    const wc = w + c;
                    if (dict.has(wc)) {
                        w = wc;
                    } else {
                        codes.push(dict.get(w));
                        dict.set(wc, dictSize++);
                        if (dictSize >= CLEAR) {
                            codes.push(CLEAR);
                            dict = new Map();
                            for (let j = 0; j < 256; j++) dict.set(String.fromCharCode(j), j);
                            dictSize = 256;
                        }
                        w = c;
                    }
                }
                if (w !== '') codes.push(dict.get(w));

                // Pack 12-bit codes
                const out = [];
                let bitBuffer = 0, bitCount = 0;
                for (let k = 0; k < codes.length; k++) {
                    const code = codes[k] & 0x0fff;
                    bitBuffer |= (code << bitCount);
                    bitCount += 12;
                    while (bitCount >= 8) {
                        out.push(bitBuffer & 0xff);
                        bitBuffer >>= 8;
                        bitCount -= 8;
                    }
                }
                if (bitCount > 0) out.push(bitBuffer & 0xff);
                return new Uint8Array(out);
            };
            const lzwDecompress = (packed) => {
                const CLEAR = 4095;
                // Unpack 12-bit codes
                const codes = [];
                let bitBuffer = 0, bitCount = 0;
                for (let i = 0; i < packed.length; i++) {
                    bitBuffer |= (packed[i] << bitCount);
                    bitCount += 8;
                    while (bitCount >= 12) {
                        const code = bitBuffer & 0x0fff;
                        codes.push(code);
                        bitBuffer >>= 12;
                        bitCount -= 12;
                    }
                }
                const reset = () => {
                    const dict = [];
                    for (let i = 0; i < 256; i++) dict[i] = String.fromCharCode(i);
                    return { dict, size: 256 };
                };
                let { dict, size } = reset();
                let w = '';
                let result = '';
                for (let i = 0; i < codes.length; i++) {
                    const k = codes[i];
                    if (k === CLEAR) { ({ dict, size } = reset()); w = ''; continue; }
                    let entry;
                    if (k < size) entry = dict[k];
                    else if (k === size && w) entry = w + w[0];
                    else return new Uint8Array(0);
                    result += entry;
                    if (w) dict[size++] = w + entry[0];
                    w = entry;
                }
                const out = new Uint8Array(result.length);
                for (let i = 0; i < result.length; i++) out[i] = result.charCodeAt(i) & 0xff;
                return out;
            };
            const encodeTasksPayload = (obj) => {
                const json = JSON.stringify(obj || {});
                const utf8 = new TextEncoder().encode(json);
                const plain = bytesToBase64Url(utf8);
                const compressed = bytesToBase64Url(lzwCompress(utf8));
                return (compressed.length + 2 < plain.length ? 'c~' + compressed : 'p~' + plain);
            };
            const decodeTasksPayload = (payload) => {
                if (!payload) throw new Error('Empty payload');
                const sep = payload.indexOf('~');
                if (sep > 0 && sep < 4) {
                    const mode = payload.slice(0, sep);
                    const body = payload.slice(sep + 1);
                    if (mode === 'c') {
                        const bytes = base64UrlToBytes(body);
                        const dec = lzwDecompress(bytes);
                        const json = new TextDecoder().decode(dec);
                        return JSON.parse(json);
                    } else if (mode === 'p') {
                        const bytes = base64UrlToBytes(body);
                        const json = new TextDecoder().decode(bytes);
                        return JSON.parse(json);
                    }
                }
                // Back-compat: treat as plain base64 JSON
                const bytes = base64UrlToBytes(payload);
                const json = new TextDecoder().decode(bytes);
                return JSON.parse(json);
            };

            const BASE_PATH = '/simple_task/';
            const BASE_URL = 'https://danielmartinscabanas.github.io' + BASE_PATH;

            const app = new Tasks();

            const addInput = document.getElementById('new-task');
            if (addInput) {
                addInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const text = (addInput.value || '').trim();
                        if (!text) return;
                        app.tasks = app.tasks || {};
                        if (app.add(text)) {
                            addInput.value = '';
                            app.render();
                        }
                    }
                });
            }

            const themeToggle = document.getElementById('theme-toggle');
            const themeStorage = new JsonStorage('theme');
            const applyTheme = (mode) => {
                document.body.setAttribute('data-theme', mode);
                // Also set on the root element so CSS variables apply to html as well
                document.documentElement.setAttribute('data-theme', mode);
                if (themeToggle) themeToggle.textContent = mode === 'dark' ? 'â˜€' : 'â˜½';
                themeStorage.save(mode);
            };
            const savedTheme = themeStorage.load() || 'light';
            applyTheme(savedTheme);
            if (themeToggle) {
                themeToggle.addEventListener('click', () => {
                    const next = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                    applyTheme(next);
                });
            }

            const exportBtn = document.getElementById('export-tasks');
            const modal = document.getElementById('export-modal');
            const shareInput = document.getElementById('share-url');
            const copyBtn = document.getElementById('copy-url');
            const closeBtn = document.getElementById('close-modal');

            const openModal = (url) => {
                if (!modal || !shareInput) return;
                shareInput.value = url;
                modal.classList.add('open');
                modal.setAttribute('aria-hidden', 'false');

                setTimeout(() => { try { shareInput.focus(); shareInput.select(); } catch(_) {} }, 0);
            };
            const closeModal = () => {
                if (!modal) return;
                modal.classList.remove('open');
                modal.setAttribute('aria-hidden', 'true');
            };

            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    try{
                        const payload = encodeTasksPayload(app.tasks || {});
                        const url = `${BASE_URL}${payload}`;
                        openModal(url);
                    } catch(err) {
                        console.error('Export failed:', err);
                    }
                });
            }

            const setCopyDefaultIcon = () => { if (copyBtn) copyBtn.innerHTML = '<img src="copy-icon.svg" alt="" class="icon-img">'; };
            if (copyBtn && shareInput) {
                copyBtn.addEventListener('click', async () => {
                    try {
                        await navigator.clipboard.writeText(shareInput.value);
                        copyBtn.textContent = 'âœ“';
                        setTimeout(setCopyDefaultIcon, 1000);
                    } catch (err) {
                        try {
                            shareInput.select();
                            document.execCommand('copy');
                            copyBtn.textContent = 'âœ“';
                            setTimeout(setCopyDefaultIcon, 1000);
                        } catch(_) {}
                    }
                });
            }
            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

            const maybeImportFromUrl = () => {
                try {
                    const path = location.pathname || '';
                    const idx = path.indexOf(BASE_PATH);
                    if (idx === -1) return false;
                    const rest = path.slice(idx + BASE_PATH.length).replace(/^\/+/, '');
                    if (!rest) return false;
                    const parsed = decodeTasksPayload(rest);
                    if (!parsed || typeof parsed !== 'object') throw new Error('Invalid data');
                    app.tasks = parsed;
                    app.storage.save(app.tasks);
                    location.replace(BASE_URL);
                    return true;
                } catch (err) {
                    console.error('URL import failed:', err);
                    return false;
                }
            };

            app.render();
            maybeImportFromUrl();

            // Register Service Worker for PWA/offline support
            if ('serviceWorker' in navigator) {
                const scope = '/simple_task/';
                navigator.serviceWorker.register('sw.js', { scope }).catch(err => {
                    console.warn('SW registration failed:', err);
                });
            }

            // Minimal Install Banner (Android/desktop with beforeinstallprompt)
            const installBanner = document.getElementById('install-banner');
            const installBtn = document.getElementById('install-cta');
            const installClose = document.getElementById('install-close');
            let deferredPrompt = null;

            const isStandalone = () => window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
            const isMobile = () => (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            const showInstallBanner = () => {
                if (!installBanner) return;
                installBanner.classList.add('show');
                installBanner.setAttribute('aria-hidden', 'false');
            };
            const hideInstallBanner = () => {
                if (!installBanner) return;
                installBanner.classList.remove('show');
                installBanner.setAttribute('aria-hidden', 'true');
            };

            window.addEventListener('beforeinstallprompt', (e) => {
                // Only show on mobile, not if already installed, and not if dismissed
                if (isStandalone() || !isMobile() || localStorage.getItem('installBannerDismissed') === '1') return;
                e.preventDefault();
                deferredPrompt = e;
                showInstallBanner();
            });
            window.addEventListener('appinstalled', () => {
                deferredPrompt = null;
                hideInstallBanner();
                localStorage.setItem('installBannerDismissed', '1');
            });
            if (installBtn) installBtn.addEventListener('click', async () => {
                try {
                    if (!deferredPrompt) return hideInstallBanner();
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    deferredPrompt = null;
                    hideInstallBanner();
                    if (outcome !== 'accepted') localStorage.setItem('installBannerDismissed', '1');
                } catch (_) { hideInstallBanner(); }
            });
            if (installClose) installClose.addEventListener('click', () => {
                localStorage.setItem('installBannerDismissed', '1');
                hideInstallBanner();
            });
        });
    </script>
</body>
</html>
